<!doctype html>
<html lang="en" class="h-100">
  <head>
  <meta name="generator" content="Hugo 0.62.1" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="https://nekrut.github.io/BMMB554/css/bootstrap.min.css">
  
  
  <title>Lecture 6: Sequence alignment I | BMMB554</title>
  <style>
.container {
  max-width: 800px;
}
#nav a {
  font-weight: bold;
  color: inherit;
}
#nav a.nav-link-active {
  background-color: #212529;
  color: #fff;
}
#nav-border {
  border-bottom: 1px solid #212529;
}
#main {
  margin-top: 1em;
  margin-bottom: 4em;
}
#home-jumbotron {
  background-color: inherit;
}
#footer .container {
  padding: 1em 0;
}
#footer a {
  color: inherit;
  text-decoration: underline;
}
.font-125 {
  font-size: 125%;
}
.tag-btn {
  margin-bottom: 0.3em;
}
pre {
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 16px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  background-color: transparent;
  border-radius: 0;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 4px;
}
img {
  max-width: 100%;
}
</style>

  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
  
</head>
  <body class="d-flex flex-column h-100">
    <div id="nav-border" class="container">
  <nav id="nav" class="nav justify-content-center">
  
  
  
    
    
      
        
      
    
    
    <a class="nav-link " href="/BMMB554/"><i data-feather="home"></i> Home</a>
  
    
    
      
        
      
    
    
    <a class="nav-link " href="/BMMB554/post/"><i data-feather="book-open"></i> Lectures</a>
  
    
    
      
        
      
    
    
    <a class="nav-link " href="/BMMB554/tags/"><i data-feather="tag"></i> Tags</a>
  
    
    
      
        
      
    
    
    <a class="nav-link " href="/BMMB554/about/"><i data-feather="list"></i> Syllabus</a>
  
  </nav>
</div>
    <div class="container">
      <main id="main">
        

<h1>Lecture 6: Sequence alignment I</h1>


<i data-feather="calendar"></i> <time datetime="2020-02-09">Feb 9, 2020</time>

  <br>
  <i data-feather="tag"></i>
  
  
  <a class="btn btn-sm btn-outline-dark tag-btn" href="https://nekrut.github.io/BMMB554/tags/alignment">alignment</a>
  
  
  <a class="btn btn-sm btn-outline-dark tag-btn" href="https://nekrut.github.io/BMMB554/tags/dynamic-programming">dynamic programming</a>
  

<br><br>
<p><img src="/BMMB554/img/topic4_cover.jpg" alt=""></p>
<p><small>The cover image shows pairwise alignments for human, mouse, and dog <em>KIF3</em> locus from <a href="http://genome.cshlp.org/content/10/9/1304.long">Dubchak et al. 2000</a>.</small></p>
<h2 id="warmup-with-python-loops">WarmUp with Python Loops</h2>
<ul>
<li>Open <a href="https://colab.research.google.com/drive/1h2Vx9uFxeWLKV3HUOxiUfv-2xRd-je2e">this notebook</a></li>
<li>Make a copy of it in your drive</li>
<li>Go through it and execute all cells</li>
</ul>
<hr>
<h1 id="introduction-to-dynamic-programming">Introduction to dynamic programming</h1>
<p><small>(Based on dynamic programming examples from <a href="http://interactivepython.org/runestone/static/pythonds/Recursion/DynamicProgramming.html">InteractivePython</a>) and excellent alignment lecture materials from <a href="http://www.langmead-lab.org/teaching-materials/">Ben Langmead</a>.</small></p>
<p>Suppose you are a cashier who's job is, generally speaking, to receive money and to give out change. Suppose that someone buys something that costs $9.37 and gives you a 10 dollar bill. You need to give $0.63 back in smallest possible number of coins. The US coin denominations are:</p>
<ul>
<li>100 (1 dollar)</li>
<li>50 (half-dollar)</li>
<li>25 (quarter)</li>
<li>10 (dime)</li>
<li>5 (nickel)</li>
<li>1 (penny)</li>
</ul>
<p>So, given these coins you will:</p>
<ol>
<li>start with the largest coin smaller than the amount you need to give back = <strong>50 Cents</strong></li>
<li>repeat for the remaining $0.13 and select <strong>10 Cents</strong>  (<strong>NOTE</strong>: this is recursion happening)</li>
<li>finish with three 1 cent counts thus you ended up with 5 (<strong>50</strong> + <strong>10</strong> +  3 × <strong>1</strong>) coins.</li>
</ol>
<h3 id="solving-problem-exhaustively">Solving problem exhaustively</h3>
<p>Now (as suggested <a href="http://interactivepython.org/runestone/static/pythonds/Recursion/DynamicProgramming.html">here</a>) suppose you are a cashier in a strange country where there is also a <strong>21</strong> cent coin in circulation. By using the algorithm above, you will still give your customer <font color="red">five</font> coins, while the &ldquo;correct&rdquo; solution will certainly be giving him/her <font color="green">three</font> <strong>21</strong> cent coins. So the algorithm we used above simply does not work.</p>
<p>Let's rephrase the problem. The smallest number of coins summing up to $0.63 cents (in our strange country with a <strong>21</strong> cent coin) will be:</p>
<ul>
<li>a minimal collection of coins summing up to $0.62 plus a <strong>1</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.58 plus a <strong>5</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.53 plus a <strong>10</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.42 plus a <strong>21</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.38 plus a <strong>25</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.13 plus a <strong>50</strong> cent coin</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/BMMB554/img/change1.png" alt=""></td>
</tr>
<tr>
<td><small><strong>Figure 1A.</strong> 1. First iteration</small></td>
</tr>
</tbody>
</table>
<hr> 
<p>Next, for each of these possibilities we will repeat this again. For example for $0.62 will consider:</p>
<ul>
<li>a minimal collection of coins summing up to $0.61 plus a <strong>1</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.57 plus a <strong>5</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.52 plus a <strong>10</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.41 plus a <strong>21</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.37 plus a <strong>25</strong> cent coin</li>
<li>a minimal collection of coins summing up to $0.12 plus a <strong>50</strong> cent coin</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/BMMB554/img/change2.png" alt=""></td>
</tr>
<tr>
<td><small><strong>Figure 1B.</strong> 2. Second iteration</small></td>
</tr>
</tbody>
</table>
<hr>
<p>And again. For $0.58 we will have:</p>
<hr>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/BMMB554/img/change3.png" alt=""></td>
</tr>
<tr>
<td><small><strong>Figure 1C.</strong> 3. Third iteration. Note that amounts highlighted in red are repeated. Below we explain why this is <strong>really bad</strong>. </small></td>
</tr>
</tbody>
</table>
<hr>
<p>and so on. Basically, as every iteration we are trying to find:</p>
<div>
<p>$$numCoins = min\begin{cases} 1 + numCoins(original_amount - 1)
&amp; \ 1 + numCoins(original_amount - 5)
&amp; \ 1 + numCoins(original_amount - 10)
&amp; \ 1 + numCoins(original_amount - 21)
&amp; \ 1 + numCoins(original_amount - 25)
&amp; \ 1 + numCoins(original_amount - 50)
\end{cases}$$</p>
</div>
<p>While this algorithm will find us the smallest number of coins necessary to give out a particular amount in change, it does this at a horrific price: it is extremely inefficient as it recomputes all possibilities at every iteration. For instance, if we ask the algorithm to compute the minimal number of coins necessary to give out 63 cents in change in a country with only four coins (1, 5, 10, and 25 cents) it will take <strong>67,716,925</strong> iterations (recursive calls). As a result you will probably loose all of your customers while they are waiting for the change.</p>
<p>The code snippet below implements this algorithm (do not worry if you don't quire understand python. It is OK for now). If you execute it (press the play button) your browser will likely crash as it will get tired waiting for result to come back (try it anyway):</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#408080;font-style:italic"># Import time function to check the speed of our code</span>
<span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

<span style="color:#408080;font-style:italic"># Below we are defining function that takes two arguments:</span>
<span style="color:#408080;font-style:italic">#   coinValueList - the list of coins circulating in your country of choice</span>
<span style="color:#408080;font-style:italic">#   change - the amount of change that needs to be given</span>
<span style="color:#408080;font-style:italic"># It return the smallest number of coins in which this amount of change can</span>
<span style="color:#408080;font-style:italic"># be given</span>

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">recMC</span>(coinValueList,change):
   minCoins <span style="color:#666">=</span> change
  
   <span style="color:#008000;font-weight:bold">if</span> change <span style="color:#a2f;font-weight:bold">in</span> coinValueList:
     <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">1</span>
   <span style="color:#008000;font-weight:bold">else</span>:
      <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> [c <span style="color:#008000;font-weight:bold">for</span> c <span style="color:#a2f;font-weight:bold">in</span> coinValueList <span style="color:#008000;font-weight:bold">if</span> c <span style="color:#666">&lt;</span><span style="color:#666">=</span> change]:
         numCoins <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#666">+</span> recMC(coinValueList,change<span style="color:#666">-</span>i)
         <span style="color:#008000;font-weight:bold">if</span> numCoins <span style="color:#666">&lt;</span> minCoins:
            minCoins <span style="color:#666">=</span> numCoins
   <span style="color:#008000;font-weight:bold">return</span> minCoins

st <span style="color:#666">=</span> time()
<span style="color:#008000;font-weight:bold">print</span>(recMC([<span style="color:#666">1</span>,<span style="color:#666">3</span>],<span style="color:#666">4</span>))
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
</code></pre></div><h3 id="caching-helps-a-bit">Caching helps a bit</h3>
<p>One potential way to solve our problem in a reasonable amount of time is to take advantage of red nodes shown in Fig. 1C above. What if before calling the function we check if a minimum number of coins for a particular amount was already computed? Apparently this speeds things up quite dramatically:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">recDC</span>(coinValueList,change,knownResults):
   minCoins <span style="color:#666">=</span> change
   <span style="color:#008000;font-weight:bold">if</span> change <span style="color:#a2f;font-weight:bold">in</span> coinValueList:
      knownResults[change] <span style="color:#666">=</span> <span style="color:#666">1</span>
      <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">1</span>
   <span style="color:#008000;font-weight:bold">elif</span> knownResults[change] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>:
      <span style="color:#008000;font-weight:bold">return</span> knownResults[change]
   <span style="color:#008000;font-weight:bold">else</span>:
       <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> [c <span style="color:#008000;font-weight:bold">for</span> c <span style="color:#a2f;font-weight:bold">in</span> coinValueList <span style="color:#008000;font-weight:bold">if</span> c <span style="color:#666">&lt;</span><span style="color:#666">=</span> change]:
         numCoins <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#666">+</span> recDC(coinValueList, change<span style="color:#666">-</span>i,
                              knownResults)
         <span style="color:#008000;font-weight:bold">if</span> numCoins <span style="color:#666">&lt;</span> minCoins:
            minCoins <span style="color:#666">=</span> numCoins
            knownResults[change] <span style="color:#666">=</span> minCoins
   <span style="color:#008000;font-weight:bold">return</span> minCoins
   
st <span style="color:#666">=</span> time()
<span style="color:#008000;font-weight:bold">print</span>(recDC([<span style="color:#666">1</span>,<span style="color:#666">5</span>,<span style="color:#666">10</span>,<span style="color:#666">25</span>],<span style="color:#666">63</span>,[<span style="color:#666">0</span>]<span style="color:#666">*</span><span style="color:#666">64</span>))
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
</code></pre></div><p>Now you can see that it takes under a second to find that it takes 3 coins to give 63 cents in change in a country with 1, 5, 10, 21, and 25 cent coins. Yet this script still makes 221 calls (better than 67,716,925, but still a lot) for find the answer.</p>
<h3 id="introducing-dynamic-programming">Introducing dynamic programming</h3>
<p>Let's flip things around. Instead of starting from <strong>63</strong> cents and going down through the tree as shown in Fig. 1A-C we will instead compute the minimal number of coins for every value from 1 to 63. To save space, let's instead assume that we need to give 11 cents in change. Let's compute a dynamic programming array for minimal number of coins between 1 and 11:</p>





<table class="table table-striped table-bordered">
<thead>
<tr>
<th>Amount</th>
<th>Minimal Number of Coins</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>11</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>for amounts between <strong>1</strong> and <strong>4</strong>, we have no choice, since we have only pennies. At <strong>5</strong> we can either use 5 pennies or 1 nickel. According to this strategy (for a country with 1, 5, 10, and 25 cent coins):</p>
<div>
<p>$$numCoins = min\begin{cases} 1 + numCoins(original_amount - 1)
&amp; \ 1 + numCoins(original_amount - 5)
&amp; \ 1 + numCoins(original_amount - 10)
&amp; \ 1 + numCoins(original_amount - 25)
\end{cases}$$</p>
</div>
<p>nickel wins (needs just 1 coin). From <strong>6</strong> to <strong>9</strong> we can either use all pennies (values will be 6, 7, 8, and 9) or a combination of nickel and pennies (values will be 2, 3, 4, 5). Again, smaller values win.</p>
<p>Let's now use this table to decide what is the minimum number of coins necessary to give 11 cents in change:</p>
<hr>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/BMMB554/img/change4.png" alt=""></td>
</tr>
<tr>
<td><small><strong>Figure 2.</strong> Making change for 11 cents. Let's look at leftmost branch. If you give 1 cent in change, you are left with 10 more to give. You consult Table 1 above and see that 10 cents can be given with 1 coin, so it will be 1 + 1 = 2 coins. In the center branch we give 5 cents in one coin and have 6 more cents to give. Looking at Table 1 tells us that 6 cents can be given in 2 coins, so 1 + 2 = 3 coins. Finally, in the rightmost branch giving 10 cents as one coin leaves 1 cent to give in change, which is also 1 coin, so 1 + 1 = 2. Thus we can either give 10 cents + 1 cent or 1 cent + 10 cents, which is equivalent since in both cases we give only 2 coins.</small></td>
</tr>
</tbody>
</table>
<hr>
<p>The following python code implements a function called <code>dynamicCoinChange</code> which computes a table (like Table 1) for any amount. In line 20 of the script we print a value corresponding to the amount we need to give back. That value is the minimum number of coins. Note that this program takes virtually no time to run.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">dynamicCoinChange</span>( coins, amount ):

	table <span style="color:#666">=</span> [ <span style="color:#666">0</span> <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>( <span style="color:#666">0</span>, amount<span style="color:#666">+</span><span style="color:#666">1</span> ) ]
	
	n <span style="color:#666">=</span> <span style="color:#008000">len</span>( coins )
	<span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>( <span style="color:#666">1</span>, amount<span style="color:#666">+</span><span style="color:#666">1</span> ):
		smallest <span style="color:#666">=</span> <span style="color:#008000">float</span>( <span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">inf</span><span style="color:#ba2121">&#34;</span> )
		<span style="color:#008000;font-weight:bold">for</span> j <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>( <span style="color:#666">0</span>, n ):
			<span style="color:#008000;font-weight:bold">if</span> ( coins[j] <span style="color:#666">&lt;</span><span style="color:#666">=</span> i ):
				smallest <span style="color:#666">=</span> <span style="color:#008000">min</span>(smallest, table[i <span style="color:#666">-</span> coins[j]]) 
		table[i] <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#666">+</span> smallest 
	<span style="color:#008000;font-weight:bold">return</span> table

amount <span style="color:#666">=</span> <span style="color:#666">63</span>
money <span style="color:#666">=</span> [<span style="color:#666">1</span>,<span style="color:#666">5</span>,<span style="color:#666">10</span>,<span style="color:#666">21</span>,<span style="color:#666">25</span>]
da <span style="color:#666">=</span> dynamicCoinChange(money, amount)

<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">It takes {} coins to give out {} cents</span><span style="color:#ba2121">&#34;</span><span style="color:#666">.</span>format(da[amount],amount))

st <span style="color:#666">=</span> time()
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
</code></pre></div><p><strong>So</strong>, dynamic programming is a methodology where complex problems are broken down to simple subproblems, that are computed just once and then used to solve the complete problem. In this example, we first pre-compute the number of coins needed to make change for any amount up to the required one, and then produce the answer.</p>
<h1 id="sequence-alignment">Sequence alignment</h1>
<p>We have just seen the principle behind dynamic programming. This approach is also extremely useful for comparing biological sequences, which is coincidentally one of the main points of this course. This lecture explain how this is done. In writing this text I heavily relied on wonderful <a href="http://www.langmead-lab.org/teaching-materials/">course</a> taught by Ben Langmead at Johns Hopkins.</p>
<h2 id="how-different-are-two-sequences">How different are two sequences?</h2>
<p>Suppose you have two sequences of the same length:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A C A T G C C T A
A C T G C C T A C
</code></pre></div><p>How different are they? In other words, how many bases should be change to turn one sequence onto the other:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A C A T G C C T A
| | * * * | * * *
A C T G C C T A C
</code></pre></div><p>the vertical lines above indicate positions that are identical between the two sequences, while asterisks show differences. It will take six substitutions to turn one sequence into the other. This number &ndash; six substitutions &ndash; is called <a href="https://en.wikipedia.org/wiki/Hamming_distance"><em>Hamming distance</em></a> or the <em>minimal</em> number of substitutions required to turn one string into another. The code below computes the Hamming distance. Try it. You can change <code>seq1</code> and <code>seq2</code> into whatever you want except that they should have the same length.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">hammingDistance</span>(x, y):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;&#39;&#39;</span><span style="color:#ba2121"> Return Hamming distance between x and y </span><span style="color:#ba2121">&#39;&#39;&#39;</span>
    <span style="color:#008000;font-weight:bold">assert</span> <span style="color:#008000">len</span>(x) <span style="color:#666">==</span> <span style="color:#008000">len</span>(y)
    nmm <span style="color:#666">=</span> <span style="color:#666">0</span>
    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">0</span>, <span style="color:#008000">len</span>(x)):
        <span style="color:#008000;font-weight:bold">if</span> x[i] <span style="color:#666">!=</span> y[i]:
            nmm <span style="color:#666">+</span><span style="color:#666">=</span> <span style="color:#666">1</span>
    <span style="color:#008000;font-weight:bold">return</span> nmm

<span style="color:#408080;font-style:italic"># You can change seq1 and seq2 to whatever you want</span>
<span style="color:#408080;font-style:italic"># But make sure that they are of the same length</span>

seq1 <span style="color:#666">=</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">ACATGCCTA</span><span style="color:#ba2121">&#39;</span>
seq2 <span style="color:#666">=</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">ACTGCCTAC</span><span style="color:#ba2121">&#39;</span>

hamDist <span style="color:#666">=</span>  hammingDistance(seq1, seq2)

<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">The Hamming distance between {} and {} is {}</span><span style="color:#ba2121">&#34;</span><span style="color:#666">.</span>format(seq1, seq2, hamDist))

</code></pre></div><p>Now in addition to <em>substitutions</em> (i.e., changing one character into another) let's allow <strong>instertions</strong> and <strong>deletions</strong>. This will essentially allow us to insert dashes (gaps) between characters:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A C A T G C C T A -
| | * | | | | | | *
A C - T G C C T A C
</code></pre></div><p>In this case the <a href="https://en.wikipedia.org/wiki/Edit_distance"><strong>edit distance</strong></a> between two sequences is 2. It is defined as the minimum number of operations (substitutions, insertions, and deletions) requited to turn one string into another. The compared strings do not have to be of the same length to be able to compute the edit distance as we can compensate for length differences using deletions and insertions. While the situation above (where we inserted two dashes) is biologically much more meaningful (and realistic), it is much more difficult to find.</p>
<h2 id="generalizing-the-problem">Generalizing the problem</h2>
<p>Before we can develop an algorithm that will help us to compute the edit distance let's develop a general framework that would allow us to think about the problem in exact terms. Let's look at a pair of VERY long sequences. So long, that we do not even see the left end &ndash; it disappears into $\infty$:</p>
<div>
        $$
                \color{red}{\texttt{.....A C T G C C T A}}\texttt{ G}\\
                \color{red}{\texttt{.....A C T G C C T A}}\texttt{ C}\\
        $$
</div>
<p>the red parts of the two sequences represent <strong>prefixes</strong> for the last nucleotides shown in black. Let's assume that the edit distance between the two prefixes is known (don't ask how we know, we just do). For simplicity let's &ldquo;compact&rdquo; the prefix of the first sequence into $\alpha$ and the prefix of the second sequence into $\beta$:</p>
<div>
        $$
                \alpha \texttt{G}\\
            \beta  \texttt{C}
        $$
</div>
<p>again, the edit distance between $\alpha$ and $\beta$ is known to us. The three possibilities for computing the edit distance between $\alpha G$ and $\beta C$ are:</p>
<div>
<p>$$Edit\ Distance(\alpha\texttt{G},\beta\texttt{C})  = min\begin{cases}
Edit\ Distance(\alpha,\beta) + 1 \leftarrow\ because\ they\ do\ not\ match&amp; \<br>
Edit\ Distance(\alpha\texttt{G},\beta) + 1 \leftarrow\ because\ we\ are\ adding\ a\ gap&amp; \<br>
Edit\ Distance(\alpha,\beta\texttt{C}) + 1 \leftarrow\ because\ we\ are\ adding\ a\ gap
\end{cases}$$</p>
</div>
<p>but we not always have $\texttt{G}$ and $\texttt{C}$ as two last nucleotiodes, so for the general case:</p>
<div>
<p>$$Edit\ Distance(\alpha\texttt{x},\beta\texttt{y}) = min\begin{cases}
Edit\ Distance(\alpha,\beta) + \delta(x,y) &amp; \<br>
Edit\ Distance(\alpha\texttt{x},\beta) + 1 &amp; \<br>
Edit\ Distance(\alpha,\beta\texttt{y}) + 1
\end{cases}$$</p>
</div>
<p>where $\delta(x,y) = 0$ if $x = y$ (nucleotides match) and $\delta(x,y) = 1$ if $x \neq y$ (nucleotides do not match). The $\delta(x,y)$ has a particular meaning. If the two nucleotides at the end are equal to each other, there is nothing to be done &ndash; no substitution operation is necessary. If a substitution is necessary however, we will record this by adding 1. When we will be talking about global and local alignment below the power of $\delta(x,y)$ will become even more clear.</p>
<p>Recall the change problem from the above. We can write an algorithm that would exhaustively evaluate the above expression for all possible suffixes. This algorithm is below. Try executing it. It will take roughly ~2 seconds to find the edit distance between the two sequences used above:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#408080;font-style:italic"># Import time function to check the speed of our code</span>
<span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">edDistRecursive</span>(x, y):
    <span style="color:#008000;font-weight:bold">global</span> n
    <span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(x) <span style="color:#666">==</span> <span style="color:#666">0</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">len</span>(y)
    <span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(y) <span style="color:#666">==</span> <span style="color:#666">0</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">len</span>(x)
    
    delt <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#008000;font-weight:bold">if</span> x[<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">!=</span> y[<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#008000;font-weight:bold">else</span> <span style="color:#666">0</span>
    <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">min</span>(edDistRecursive(x[:<span style="color:#666">-</span><span style="color:#666">1</span>], y[:<span style="color:#666">-</span><span style="color:#666">1</span>]) <span style="color:#666">+</span> delt, 
               edDistRecursive(x[:<span style="color:#666">-</span><span style="color:#666">1</span>], y) <span style="color:#666">+</span> <span style="color:#666">1</span>, 
               edDistRecursive(x, y[:<span style="color:#666">-</span><span style="color:#666">1</span>]) <span style="color:#666">+</span> <span style="color:#666">1</span>)
st <span style="color:#666">=</span> time()
<span style="color:#008000;font-weight:bold">print</span>(edDistRecursive(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">ACATGCCTA</span><span style="color:#ba2121">&#34;</span>,<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">ACTGCCTAC</span><span style="color:#ba2121">&#34;</span>))
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
</code></pre></div><p>Again, don't worry if Python looks scary to you. The take-home-message here is that it takes a very long time to compute the edit distance between two sequences that are only <strong>nine</strong> nucleotides long! Why is this happening? Fig. 3 below shows a small subset of situations the algorithm is evaluating for two very short strings $\texttt{TAG}$ and $\texttt{TAC}$:</p>
<hr>
|                 |
|-----------------|
|![](/BMMB554/img/editDist.png)|
|<small>**Figure 3**. A fraction of situations evaluated by the naïve algorithm for computing the edit distance. Just like in the case of the change problem discussed in the previous lecture a lot of time is wasted on computing distances between suffixes that has been seen more than once (shown in red).</small>|
<hr>
<p>To understand the magnitude of this problem let's look at slightly modified version of the previous Python code below. All we do here is keeping track how many times a particular pair of suffixes (in this case $\texttt{AC}$ and $\texttt{AC}$) are seen by the program. The number is staggering: 48,639. So this algorithm is <strong>extremely</strong> wasteful.</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3"><span style="color:#408080;font-style:italic"># Import time function to check the speed of our code</span>
<span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

n <span style="color:#666">=</span> <span style="color:#666">0</span>

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">edDistRecursive</span>(x, y):
    <span style="color:#008000;font-weight:bold">global</span> n
    <span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(x) <span style="color:#666">==</span> <span style="color:#666">0</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">len</span>(y)
    <span style="color:#008000;font-weight:bold">if</span> <span style="color:#008000">len</span>(y) <span style="color:#666">==</span> <span style="color:#666">0</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">len</span>(x)
    
    <span style="color:#408080;font-style:italic"># Let&#39;s keep track of how many times prefix TA is seen </span>
    
    <span style="color:#008000;font-weight:bold">if</span> x <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">TA</span><span style="color:#ba2121">&#39;</span> <span style="color:#a2f;font-weight:bold">and</span> y <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">TA</span><span style="color:#ba2121">&#39;</span>:
      n <span style="color:#666">+</span><span style="color:#666">=</span> <span style="color:#666">1</span>
    delt <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#008000;font-weight:bold">if</span> x[<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">!=</span> y[<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#008000;font-weight:bold">else</span> <span style="color:#666">0</span>
    <span style="color:#008000;font-weight:bold">return</span> <span style="color:#008000">min</span>(edDistRecursive(x[:<span style="color:#666">-</span><span style="color:#666">1</span>], y[:<span style="color:#666">-</span><span style="color:#666">1</span>]) <span style="color:#666">+</span> delt, 
               edDistRecursive(x[:<span style="color:#666">-</span><span style="color:#666">1</span>], y) <span style="color:#666">+</span> <span style="color:#666">1</span>, 
               edDistRecursive(x, y[:<span style="color:#666">-</span><span style="color:#666">1</span>]) <span style="color:#666">+</span> <span style="color:#666">1</span>)
st <span style="color:#666">=</span> time()
<span style="color:#008000">print</span>(edDistRecursive(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">TAG</span><span style="color:#ba2121">&#34;</span>,<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">TAC</span><span style="color:#ba2121">&#34;</span>))
<span style="color:#008000">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
<span style="color:#008000">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">TA,TA is seen </span><span style="color:#b68;font-weight:bold">{}</span><span style="color:#ba2121"> times</span><span style="color:#ba2121">&#34;</span><span style="color:#666">.</span>format(n))
</code></pre></div><p>While this approach to the edit distance problem is correct, it will hardly help us on the genome-wide scale. Just like in case of the change problem dynamic programming is going to save the day.</p>
<h2 id="dynamic-programming-to-the-rescue">Dynamic programming to the rescue</h2>
<p>Our goal is to find an optimal <strong>alignment</strong> between two sequences. Note that so far this is the first time we use the term <strong>alignment</strong> in this section. It turns out that in order to find the alignment we first need to learn how to compute edit distances between sequences efficiently. So, suppose we have two sequences that deliberately have different lengths:</p>
<p>$\texttt{G C T A T A C}$</p>
<p>and</p>
<p>$\texttt{G C G T A T G C}$</p>
<p>Let's represent them as the following matrix where the first character $\epsilon$ represents an empty string:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon\\
                                        \hline
                                        G\\
                                        \hline
                                        C\\
                                        \hline
                                        G\\
                                        \hline
                                        T\\
                                        \hline
                                        A\\
                                        \hline
                                        T\\
                                        \hline
                                        G\\
                                        \hline
                                        C
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>Let's fill the first column and first raw of the matrix. Because the distance between a string and an empty string is equal to the length of the string (e.g., a distance between string $\texttt{TCG}$ and an empty string is 3) this resulting matrix will look like this:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                        G & 1\\
                                        \hline
                                        C & 2\\
                                        \hline
                                        G & 3\\
                                        \hline
                                        T & 4\\
                                        \hline
                                        A & 5\\
                                        \hline
                                        T & 6\\
                                        \hline
                                        G & 7\\
                                        \hline
                                        C & 8
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>Now, let's fill in the cell between $\texttt{G}$ and $\texttt{G}$. Recall that:</p>
<div>
<p>$$Edit\ Distance(\alpha\texttt{x},\beta\texttt{y}) = min\begin{cases}
\color{red}{Edit\ Distance(\alpha,\beta) + \delta(x,y)} &amp; \<br>
\color{blue}{Edit\ Distance(\alpha\texttt{x},\beta) + 1} &amp; \<br>
\color{green}{Edit\ Distance(\alpha,\beta\texttt{y}) + 1}
\end{cases}$$</p>
</div>
<p>where $\delta(x,y) = 0$ if $x = y$ and $\delta(x,y) = 1$ if $x \neq y$. And now let's color each of the cells corresponding to each part of the above expression:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & \color{red}0 & \color{green}1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                        G & \color{blue}1\\
                                        \hline
                                        C & 2\\
                                        \hline
                                        G & 3\\
                                        \hline
                                        T & 4\\
                                        \hline
                                        A & 5\\
                                        \hline
                                        T & 6\\
                                        \hline
                                        G & 7\\
                                        \hline
                                        C & 8
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>In this specific case:</p>
<div>
<p>$$Edit\ Distance(\epsilon\texttt{G},\epsilon\texttt{G}) = min\begin{cases}
\color{red}{Edit\ Distance(\epsilon,\epsilon) + \delta(G,G)\ or\ 0\ +\ 0\ =\ 0} &amp; \<br>
\color{blue}{Edit\ Distance(\epsilon\texttt{G},\epsilon) + 1\ or\ 1\ +\ 1\ =\ 2} &amp; \<br>
\color{green}{Edit\ Distance(\epsilon,\epsilon\texttt{G}) + 1\ or\ 1\ +\ 1\ =\ 2}
\end{cases}$$</p>
</div>
<p>This minimum of 0, 2, and 2 will be 0, so we are putting zero into that cell:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C \\
                                        \hline
                                        \epsilon & \color{red}0 & \color{green}1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                        G & \color{blue}1 & \color{red}0\\
                                        \hline
                                        C & 2\\
                                        \hline
                                        G & 3\\
                                        \hline
                                        T & 4\\
                                        \hline
                                        A & 5\\
                                        \hline
                                        T & 6\\
                                        \hline
                                        G & 7\\
                                        \hline
                                        C & 8
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>Using this uncomplicated logic we can fill the entire matrix like this:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                               G & 1 & 0 & 1 & 2 & 3 & 4 & 5 & 6\\
                                        \hline
                                               C & 2 & 1 & 0 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               G & 3 & 2 & 1 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               T & 4 & 3 & 2 & 1 & 2 & 2 & 3 & 4\\
                                        \hline
                                               A & 5 & 4 & 3 & 2 & 1 & 2 & 2 & 3\\
                                        \hline
                                               T & 6 & 5 & 4 & 3 & 2 & 1 & 2 & 3\\
                                        \hline
                                               G & 7 & 6 & 5 & 4 & 3 & 2 & 2 & 3\\
                                        \hline
                                               C & 8 & 7 & 6 & 5 & 4 & 3 & 3 & \color{red}2
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>The lower rightmost cell highlighted in red is special. It contains the value for the edit distance between the two strings. The following Python script implements this idea. You can see that it is essentially instantaneous:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">numpy</span> <span style="color:#008000;font-weight:bold">as</span> <span style="color:#00f;font-weight:bold">np</span>
<span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">time</span> <span style="color:#008000;font-weight:bold">import</span> time

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">edDistDp</span>(x, y):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#34;&#34;&#34;</span><span style="color:#ba2121"> Calculate edit distance between sequences x and y using</span><span style="color:#ba2121">
</span><span style="color:#ba2121"></span><span style="color:#ba2121">        matrix dynamic programming.  Return distance. </span><span style="color:#ba2121">&#34;&#34;&#34;</span>
    D <span style="color:#666">=</span> np<span style="color:#666">.</span>zeros((<span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>), dtype<span style="color:#666">=</span><span style="color:#008000">int</span>)
    D[<span style="color:#666">0</span>, <span style="color:#666">1</span>:] <span style="color:#666">=</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>)
    D[<span style="color:#666">1</span>:, <span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>)
    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>):
        <span style="color:#008000;font-weight:bold">for</span> j <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>):
            delt <span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#008000;font-weight:bold">if</span> x[i<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">!=</span> y[j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#008000;font-weight:bold">else</span> <span style="color:#666">0</span>
            D[i, j] <span style="color:#666">=</span> <span style="color:#008000">min</span>(D[i<span style="color:#666">-</span><span style="color:#666">1</span>, j<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">+</span>delt, D[i<span style="color:#666">-</span><span style="color:#666">1</span>, j]<span style="color:#666">+</span><span style="color:#666">1</span>, D[i, j<span style="color:#666">-</span><span style="color:#666">1</span>]<span style="color:#666">+</span><span style="color:#666">1</span>)
    <span style="color:#008000;font-weight:bold">return</span> D[<span style="color:#008000">len</span>(x), <span style="color:#008000">len</span>(y)]

st <span style="color:#666">=</span> time()
<span style="color:#008000;font-weight:bold">print</span>( edDistDp(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">GCGTATGCACGC</span><span style="color:#ba2121">&#39;</span>, <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">GCTATGCCACGC</span><span style="color:#ba2121">&#39;</span>) )
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">Took </span><span style="color:#b68;font-weight:bold">%0.3f</span><span style="color:#ba2121"> seconds</span><span style="color:#ba2121">&#39;</span> <span style="color:#666">%</span> (time() <span style="color:#666">-</span> st))
</code></pre></div><h2 id="from-edit-distance-to-alignment">From edit distance to alignment</h2>
<p>In the previous section we have filled the dynamic programming matrix to find out that the edit distance between the sequences is 2. But in biological applications we are most often interested not in edit distance <em>per se</em> but in the actual <strong>alignment</strong> between two sequences.</p>
<h3 id="the-traceback">The traceback</h3>
<p>We can use the dynamic programming matrix to reconstruct the alignment. This is done using <strong>traceback</strong> procedure. Let's look at the rightmost bottom cell of the matrix highlighted in <strong>bold</strong>:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                               G & 1 & 0 & 1 & 2 & 3 & 4 & 5 & 6\\
                                        \hline
                                               C & 2 & 1 & 0 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               G & 3 & 2 & 1 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               T & 4 & 3 & 2 & 1 & 2 & 2 & 3 & 4\\
                                        \hline
                                               A & 5 & 4 & 3 & 2 & 1 & 2 & 2 & 3\\
                                        \hline
                                               T & 6 & 5 & 4 & 3 & 2 & 1 & 2 & 3\\
                                        \hline
                                               G & 7 & 6 & 5 & 4 & 3 & 2 & 2 & 3\\
                                        \hline
                                               C & 8 & 7 & 6 & 5 & 4 & 3 & 3 & \textbf{2}
<p>\end{array}</p>
<pre><code>    $$
</code></pre>
</div>
<p>When we were filling this matrix did we come to this point from above ($\color{green}3$), from the left ($\color{blue}3$), or diagonally ($\color{red}2$):</p>
<div>
        $$
        \begin{array}{ | c | c }
                    \hline
                                   \color{red}2 & \color{green}3\\
                                \hline
                                   \color{blue}3 & \textbf{2}
        \end{array}
        $$
</div>
<p>Remembering the fact that when filling the matrix we are trying to minimize the expression for edit distance, we clearly arrived to this point diagonally from $\color{red}2$. This because arriving from top ($\color{green}3$) or left ($\color{blue}3$) would add 1. So we highlight diagonal cell in red:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                               G & 1 & 0 & 1 & 2 & 3 & 4 & 5 & 6\\
                                        \hline
                                               C & 2 & 1 & 0 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               G & 3 & 2 & 1 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               T & 4 & 3 & 2 & 1 & 2 & 2 & 3 & 4\\
                                        \hline
                                               A & 5 & 4 & 3 & 2 & 1 & 2 & 2 & 3\\
                                        \hline
                                               T & 6 & 5 & 4 & 3 & 2 & 1 & 2 & 3\\
                                        \hline
                                               G & 7 & 6 & 5 & 4 & 3 & 2 & \color{red}2 & 3\\
                                        \hline
                                               C & 8 & 7 & 6 & 5 & 4 & 3 & 3 & \color{red}2
<p>\end{array}
$$</p>
</div>
<p>Continuing this idea we will draw a trace like the one below until we hit an interesting point:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                               G & 1 & 0 & 1 & 2 & 3 & 4 & 5 & 6\\
                                        \hline
                                               C & 2 & 1 & 0 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               G & 3 & 2 & \color{red}1 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               T & 4 & 3 & 2 & \color{red}1 & 2 & 2 & 3 & 4\\
                                        \hline
                                               A & 5 & 4 & 3 & 2 & \color{red}1 & 2 & 2 & 3\\
                                        \hline
                                               T & 6 & 5 & 4 & 3 & 2 & \color{red}1 & 2 & 3\\
                                        \hline
                                               G & 7 & 6 & 5 & 4 & 3 & 2 & \color{red}2 & 3\\
                                        \hline
                                               C & 8 & 7 & 6 & 5 & 4 & 3 & 3 & \color{red}2
<p>\end{array}
$$</p>
</div>
<p>At this point we have arrived to this value from the top because 0 + 1 = 1. If we were arriving diagonally it would be 1 + 1 = 2 since $\texttt{G}\ \neq\ \texttt{C}$, so we are turning traceback upward and then again diagonally:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & G & C & T & A & T & A & C\\
                                        \hline
                                        \epsilon & \color{red}0 & 1 & 2 & 3 & 4 & 5 & 6 & 7\\
                                        \hline
                                               G & 1 & \color{red}0 & 1 & 2 & 3 & 4 & 5 & 6\\
                                        \hline
                                               C & 2 & 1 & \color{red}0 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               G & 3 & 2 & \color{red}1 & 1 & 2 & 3 & 4 & 5\\
                                        \hline
                                               T & 4 & 3 & 2 & \color{red}1 & 2 & 2 & 3 & 4\\
                                        \hline
                                               A & 5 & 4 & 3 & 2 & \color{red}1 & 2 & 2 & 3\\
                                        \hline
                                               T & 6 & 5 & 4 & 3 & 2 & \color{red}1 & 2 & 3\\
                                        \hline
                                               G & 7 & 6 & 5 & 4 & 3 & 2 & \color{red}2 & 3\\
                                        \hline
                                               C & 8 & 7 & 6 & 5 & 4 & 3 & 3 & \color{red}2
<p>\end{array}
$$</p>
</div>
<p>Now going through traceback line from the top we are getting the following alignment between two two sequences:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">G C - T A T A C
| | * | | | * |
G C G T A T G C
</code></pre></div><h3 id="approximate-matching">Approximate matching</h3>
<p>Let's now get a bit more practical. In many real biological applications we are trying to see if one sequence is contained within another. So, how can we use dynamic programming to find if there is an approximate match between two sequences $\it\texttt{P}$ and $\texttt{T}$?</p>
<p>Suppose we have two strings:</p>
<p>$\it{T} = \texttt{A A C C C T A T G T C A T G C C T T G G A}$</p>
<p>and</p>
<p>$\it{P} = \texttt{T A C G T C A G C}$</p>
<p>Let's construct the following matrix:</p>
<div>
$$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                        & \epsilon & A & A & C & C & C & T & A & T & G & T & C & A & T & G & C & C & T & T & G & G & A\\
                                        \hline
                                                   \\
                                        \hline
                                                  T\\
                                        \hline
                                                  A\\
                                        \hline
                                                  C\\
                                        \hline
                                                  G\\
                                        \hline
                                                  T\\
                                        \hline
                                                  C\\
                                        \hline
                                                  A\\
                                        \hline
                                                  G\\
                                        \hline
                                                          C\\
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{T}\ is\ horizontal\ while\ \texttt{P}\ is\ vertical.</p>
<p>$$</p>
</div>
<p>Let me remind you that our goal is to find where $\it\texttt{P}$ matches $\texttt{T}$. <em>A priori</em> we do not know when it may be, so we will start by filling the entire first row with zeros. This is because the match between $\it\texttt{P}$ and $\texttt{T}$ may start at any point up there. The first column we will initialize the same way we did previously: with increasing sequence of numbers:</p>
<div>
$$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                        & \epsilon & A & A & C & C & C & T & A & T & G & T & C & A & T & G & C & C & T & T & G & G & A\\
                                        \hline
                                                 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                        \hline
                                             T & 1\\
                                        \hline
                                             A & 2\\
                                        \hline
                                             C & 3\\
                                        \hline
                                             G & 4\\
                                        \hline
                                             T & 5\\
                                        \hline
                                             C & 6\\
                                        \hline
                                             A & 7\\
                                        \hline
                                             G & 8\\
                                        \hline
                                                 C & 9\\
<p>\end{array}
$$</p>
</div>
<p>Now let's fill this matrix in using the same logic we used before:</p>
<div>
$$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                        & \epsilon & A & A & C & C & C & T & A & T & G & T & C & A & T & G & C & C & T & T & G & G & A\\
                                        \hline
                                                 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                        \hline
                                               T & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1\\
                                        \hline
                                               A & 2 & 1 & 1 & 2 & 2 & 2 & 1 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 2 & 2 & 1 & 1 & 1 & 2 & 1\\
                                        \hline
                                               C & 3 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & 1 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & 2 & 2 & 2 & 2 & 2 & 2\\
                                        \hline
                                               G & 4 & 3 & 3 & 2 & 2 & 3 & 3 & 2 & 2 & 1 & 2 & 2 & 2 & 3 & 2 & 2 & 2 & 3 & 3 & 2 & 2 & 3\\
                                        \hline
                                               T & 5 & 4 & 4 & 3 & 3 & 3 & 3 & 3 & 2 & 2 & 1 & 2 & 3 & 2 & 3 & 3 & 3 & 2 & 3 & 3 & 3 & 3\\
                                        \hline
                                               C & 6 & 5 & 5 & 4 & 3 & 3 & 4 & 4 & 3 & 3 & 2 & 1 & 2 & 3 & 3 & 3 & 3 & 3 & 3 & 4 & 4 & 4\\
                                        \hline
                                               A & 7 & 6 & 5 & 5 & 4 & 4 & 4 & 4 & 4 & 4 & 3 & 2 & 1 & 2 & 3 & 4 & 4 & 4 & 4 & 4 & 5 & 4\\
                                        \hline
                                               G & 8 & 7 & 6 & 6 & 5 & 5 & 5 & 5 & 5 & 4 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 & 5 & 4 & 4 & 5\\
                                        \hline
                                                   C & 9 & 8 & 7 & 6 & 6 & 5 & 6 & 6 & 6 & 5 & 5 & 4 & 3 & 3 & 3 & 2 & 3 & 4 & 5 & 5 & 5 & 5
<p>\end{array}
$$</p>
</div>
<p>Now that we have filled in the complete matrix let's look at the bottom row. Instead of using the rightmost cell we will find a cell with the lowest number. That would be 2 (highlighted in red):</p>
<div>
$$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                        & \epsilon & A & A & C & C & C & T & A & T & G & T & C & A & T & G & C & C & T & T & G & G & A\\
                                        \hline
                                                 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                        \hline
                                               T & 1 & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1\\
                                        \hline
                                               A & 2 & 1 & 1 & 2 & 2 & 2 & 1 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 2 & 2 & 1 & 1 & 1 & 2 & 1\\
                                        \hline
                                               C & 3 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & 1 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & 2 & 2 & 2 & 2 & 2 & 2\\
                                        \hline
                                               G & 4 & 3 & 3 & 2 & 2 & 3 & 3 & 2 & 2 & 1 & 2 & 2 & 2 & 3 & 2 & 2 & 2 & 3 & 3 & 2 & 2 & 3\\
                                        \hline
                                               T & 5 & 4 & 4 & 3 & 3 & 3 & 3 & 3 & 2 & 2 & 1 & 2 & 3 & 2 & 3 & 3 & 3 & 2 & 3 & 3 & 3 & 3\\
                                        \hline
                                               C & 6 & 5 & 5 & 4 & 3 & 3 & 4 & 4 & 3 & 3 & 2 & 1 & 2 & 3 & 3 & 3 & 3 & 3 & 3 & 4 & 4 & 4\\
                                        \hline
                                               A & 7 & 6 & 5 & 5 & 4 & 4 & 4 & 4 & 4 & 4 & 3 & 2 & 1 & 2 & 3 & 4 & 4 & 4 & 4 & 4 & 5 & 4\\
                                        \hline
                                               G & 8 & 7 & 6 & 6 & 5 & 5 & 5 & 5 & 5 & 4 & 4 & 3 & 2 & 2 & 2 & 3 & 4 & 5 & 5 & 4 & 4 & 5\\
                                        \hline
                                                   C & 9 & 8 & 7 & 6 & 6 & 5 & 6 & 6 & 6 & 5 & 5 & 4 & 3 & 3 & 3 & \color{red}2 & 3 & 4 & 5 & 5 & 5 & 5
<p>\end{array}
$$</p>
</div>
<p>Starting already familiar traceback procedure at that cell we will get the following path through the matrix:</p>
<div>
$$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                        & \epsilon & A & A & C & C & C & T & A & T & G & T & C & A & T & G & C & C & T & T & G & G & A\\
                                        \hline
                                                 & 0 & 0 & 0 & 0 & 0 & \color{red}0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                        \hline
                                               T & 1 & 1 & 1 & 1 & 1 & 1 & \color{red}0 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 1 & 1\\
                                        \hline
                                               A & 2 & 1 & 1 & 2 & 2 & 2 & 1 & \color{red}0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 2 & 2 & 1 & 1 & 1 & 2 & 1\\
                                        \hline
                                               C & 3 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & \color{red}1 & 2 & 2 & 1 & 2 & 2 & 2 & 1 & 2 & 2 & 2 & 2 & 2 & 2\\
                                        \hline
                                               G & 4 & 3 & 3 & 2 & 2 & 3 & 3 & 2 & 2 & \color{red}1 & 2 & 2 & 2 & 3 & 2 & 2 & 2 & 3 & 3 & 2 & 2 & 3\\
                                        \hline
                                               T & 5 & 4 & 4 & 3 & 3 & 3 & 3 & 3 & 2 & 2 & \color{red}1 & 2 & 3 & 2 & 3 & 3 & 3 & 2 & 3 & 3 & 3 & 3\\
                                        \hline
                                               C & 6 & 5 & 5 & 4 & 3 & 3 & 4 & 4 & 3 & 3 & 2 & \color{red}1 & 2 & 3 & 3 & 3 & 3 & 3 & 3 & 4 & 4 & 4\\
                                        \hline
                                               A & 7 & 6 & 5 & 5 & 4 & 4 & 4 & 4 & 4 & 4 & 3 & 2 & \color{red}1 & \color{red}2 & 3 & 4 & 4 & 4 & 4 & 4 & 5 & 4\\
                                        \hline
                                               G & 8 & 7 & 6 & 6 & 5 & 5 & 5 & 5 & 5 & 4 & 4 & 3 & 2 & 2 & \color{red}2 & 3 & 4 & 5 & 5 & 4 & 4 & 5\\
                                        \hline
                                                   C & 9 & 8 & 7 & 6 & 6 & 5 & 6 & 6 & 6 & 5 & 5 & 4 & 3 & 3 & 3 & \color{red}2 & 3 & 4 & 5 & 5 & 5 & 5
<p>\end{array}
$$</p>
</div>
<p>for a corresponding alignment:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">A A C C C T A T G T C A T G C C T T G G A
          | | * | | | | * | | 
          T A C G T C A - G C
</code></pre></div><hr>
<h2 id="global-alignment">Global alignment</h2>
<p>So far in filling the dynamic programming matrix we were using the following expression to compute the number within each cell:</p>
<div>
<p>$$Edit\ Distance(\alpha\texttt{x},\beta\texttt{y}) = min\begin{cases}
\color{red}{Edit\ Distance(\alpha,\beta) + \delta(x,y)} &amp; \<br>
\color{blue}{Edit\ Distance(\alpha\texttt{x},\beta) + 1} &amp; \<br>
\color{green}{Edit\ Distance(\alpha,\beta\texttt{y}) + 1}
\end{cases}$$</p>
</div>
<p>Basically we were adding 1 if there was a mismatch (the $\delta$ function) and also adding 1 for every gap. This however is not biologically realistic. If we look at the rates of different rates of mutations in the human genome we will see that they vary dramatically. Let's look at substitutions first:</p>
<hr>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="/BMMB554/img/TsTv.png" alt=""></td>
</tr>
<tr>
<td><small><strong>Figure 4</strong>. There are two kinds of nucleotide substitutions: Transitions and Transversions. Transitions are substitutions between nucleotides belonging to the same chemical group. For example, a substitution of Adenine, a purine, to Guanine, also a purine, is a transition. Transversions, on the other hand, occur between chemically dissimilar nucleotides. For example, any substitution of a purine to a pyrimidine and vice verse will be a transition. (Image from <a href="https://en.wikipedia.org/wiki/Transversion">Wikipedia</a>)</small></td>
</tr>
</tbody>
</table>
<hr>
you can see that there are move ways in which we can have a transversion. Despite this fact transversions are significantly less frequent that transitions. In fact in human the so called *Transition/Transversion ratio* ($Ts:Tv$) is close to [2](http://www.pnas.org/content/107/3/961.long) (or even higher in [coding regions](http://genomebiology.biomedcentral.com/articles/10.1186/gb-2011-12-9-r84)).
<p>The situation with insertions and deletions (that are often called <em>indels</em>) is similar in that are relatively rare and their rarity increases with size. A single nucleotide indel may occur every 1,000 bases on average, while a two-nucleotide deletion occurs every 3,000 bases and so on (see <a href="http://genome.cshlp.org/content/23/5/749.abstract">Montgomery et al. 2013</a> for a more detailed statistics).</p>
<p>As a result it is simply unrealistic to use &ldquo;1&rdquo; is all cases. Instead, we need to <em>penalize</em> rare events more than we penalize frequent, more probable events. Let's create a <em>penalty matrix</em> to achieve this goal:</p>
<div>
        $$
        \begin{array}{ c | c  c  c  c  c }
                                     & A & C & G & T & -\\
                                  \hline
                                   A & 0 & \color{blue}4 & \color{red}2 & \color{blue}4 & \color{orange}8\\  
                                   C & \color{blue}4 & 0 & \color{blue}4 & \color{red}2 & \color{orange}8\\
                                   G & \color{red}2 & \color{blue}4 & 0 & \color{blue}4 & \color{orange}8\\
                                   T & \color{blue}4 & \color{red}2 & \color{blue}4 & 0 & \color{orange}8\\
                                   - & \color{orange}8 & \color{orange}8 & \color{orange}8 & \color{orange}8 & \\
                                \hline
<pre><code>    \end{array}
    $$
</code></pre>
</div>
<p>Here if two nucleotides match, the penalty is 0. For a transitional substitution we pay $\color{red}2$ and for a transversional we pay $\color{blue}4$. The gap is the most expensive at $\color{orange}8$.</p>
<p>Now, let's align two sequences:</p>
<p>$\it{X} = \texttt{T A T G T C A T G C}$</p>
<p>and</p>
<p>$\it{Y} = \texttt{T A C G T C A G C}$</p>
<p>First, we need to fill the following dynamic programming matrix:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & T & A & T & G & T & C & A & T & G & C\\
                                        \hline
                                        \epsilon \\
                                        \hline
                                               T \\
                                        \hline
                                               A \\
                                        \hline
                                               C \\
                                        \hline
                                               G \\
                                        \hline
                                               T \\
                                        \hline
                                               C \\
                                        \hline
                                               A \\
                                        \hline
                                               G \\
                                    \hline
                                           C 
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>But now we using penalty matrix generated above to calculate values in each cell. Specifically, before we were using this expression:</p>
<div>
<p>$$Edit\ Distance(\alpha\texttt{x},\beta\texttt{y}) = min\begin{cases}
Edit\ Distance(\alpha,\beta) + \delta(x,y) &amp; \<br>
Edit\ Distance(\alpha\texttt{x},\beta) + 1 &amp; \<br>
Edit\ Distance(\alpha,\beta\texttt{y}) + 1
\end{cases}$$</p>
</div>
<p>but now, we will change it into this:</p>
<div>
<p>$$D(\alpha\texttt{x},\beta\texttt{y}) = min\begin{cases}
D(\alpha,\beta) + p\texttt{(x,y)} &amp; \<br>
D(\alpha\texttt{x},\beta) + p\texttt{(x,-)} &amp; \<br>
D(\alpha,\beta\texttt{y}) + p\texttt{(-,y)}
\end{cases}$$</p>
</div>
<p>where $p\texttt{(x,y)}$, $p\texttt{(x,-)}$, and $p\texttt{(-,y)}$ are taken directly from penalty matrix. Let's start with the first row. In this row we can only fill from the left were we essentially inserting a gap every time. Since the gap penalty is 8 we will get:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & T & A & T & G & T & C & A & T & G & C\\
                                        \hline
                                \epsilon & 0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72 & 80\\
                                        \hline
                                               T \\
                                        \hline
                                               A \\
                                        \hline
                                               C \\
                                        \hline
                                               G \\
                                        \hline
                                               T \\
                                        \hline
                                               C \\
                                        \hline
                                               A \\
                                        \hline
                                               G \\
                                    \hline
                                           C 
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Note}: sequence\ \texttt{X}\ is\ vertical\ and\ sequence\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>Similarly, for the first column we get:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & T & A & T & G & T & C & A & T & G & C\\
                                        \hline
                                \epsilon & 0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72 & 80\\
                                        \hline
                                               T & 8\\
                                        \hline
                                               A & 16\\
                                        \hline
                                               C & 24\\
                                        \hline
                                               G & 32\\
                                        \hline
                                               T & 40\\
                                        \hline
                                               C & 48\\
                                        \hline
                                               A & 56\\
                                        \hline
                                               G & 64\\
                                    \hline
                                           C & 72
<p>\end{array}
$$</p>
</div>
<p>and finally the full matrix:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & T & A & T & G & T & C & A & T & G & C\\
                                        \hline
                                \epsilon & 0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72 & 80\\
                                        \hline
                                               T & 8 & 0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72\\
                                        \hline
                                               A & 16 & 8 & 0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64\\
                                        \hline
                                               C & 24 & 16 & 8 & 2 & 10 & 18 & 24 & 32 & 40 & 48 & 56\\
                                        \hline
                                               G & 32 & 24 & 16 & 10 & 2 & 10 & 18 & 26 & 34 & 40 & 48\\
                                        \hline
                                               T & 40 & 32 & 24 & 16 & 10 & 2 & 10 & 18 & 26 & 34 & 42\\
                                        \hline
                                               C & 48 & 40 & 32 & 24 & 18 & 10 & 2 & 10 & 18 & 26 & 34\\
                                        \hline
                                               A & 56 & 48 & 40 & 32 & 26 & 18 & 10 & 2 & 10 & 18 & 26\\
                                        \hline
                                               G & 64 & 56 & 48 & 40 & 32 & 26 & 18 & 10 & 6 & 10 & 18\\
                                    \hline
                                           C & 72 & 64 & 56 & 48 & 40 & 34 & 26 & 18 & 12 & 10 & 10
<p>\end{array}
$$</p>
</div>
<p>Drawing a traceback through this matrix will give us:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c}
                                         & \epsilon & T & A & T & G & T & C & A & T & G & C\\
                                        \hline
                                \epsilon & \color{red}0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72 & 80\\
                                        \hline
                                               T & 8 & \color{red}0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64 & 72\\
                                        \hline
                                               A & 16 & 8 & \color{red}0 & 8 & 16 & 24 & 32 & 40 & 48 & 56 & 64\\
                                        \hline
                                               C & 24 & 16 & 8 & \color{red}2 & 10 & 18 & 24 & 32 & 40 & 48 & 56\\
                                        \hline
                                               G & 32 & 24 & 16 & 10 & \color{red}2 & 10 & 18 & 26 & 34 & 40 & 48\\
                                        \hline
                                               T & 40 & 32 & 24 & 16 & 10 & \color{red}2 & 10 & 18 & 26 & 34 & 42\\
                                        \hline
                                               C & 48 & 40 & 32 & 24 & 18 & 10 & \color{red}2 & 10 & 18 & 26 & 34\\
                                        \hline
                                               A & 56 & 48 & 40 & 32 & 26 & 18 & 10 & \color{red}2 & \color{red}{10} & 18 & 26\\
                                        \hline
                                               G & 64 & 56 & 48 & 40 & 32 & 26 & 18 & 10 & 6 & \color{red}{10} & 18\\
                                    \hline
                                           C & 72 & 64 & 56 & 48 & 40 & 34 & 26 & 18 & 12 & 10 & \color{red}{10}
<p>\end{array}
$$</p>
</div>
<p>This corresponds to the following alignment:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">T A C G T C A - G C
| | * | | | | * | | 
T A T G T C A T G C
</code></pre></div><p>The following Python code implements Global alignment approach we have seen above. Note that the first function, <code>exampleCost</code>, can be changed to set different value for the penalty matrix. You can play with it here:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">numpy</span> <span style="color:#008000;font-weight:bold">import</span> zeros

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">exampleCost</span>(xc, yc):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#34;&#34;&#34;</span><span style="color:#ba2121"> Cost function assigning 0 to match, 2 to transition, 4 to</span><span style="color:#ba2121">
</span><span style="color:#ba2121"></span><span style="color:#ba2121">        transversion, and 8 to a gap </span><span style="color:#ba2121">&#34;&#34;&#34;</span>
    <span style="color:#008000;font-weight:bold">if</span> xc <span style="color:#666">==</span> yc: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">0</span> <span style="color:#408080;font-style:italic"># match</span>
    <span style="color:#008000;font-weight:bold">if</span> xc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span> <span style="color:#a2f;font-weight:bold">or</span> yc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">8</span> <span style="color:#408080;font-style:italic"># gap</span>
    minc, maxc <span style="color:#666">=</span> <span style="color:#008000">min</span>(xc, yc), <span style="color:#008000">max</span>(xc, yc)
    <span style="color:#008000;font-weight:bold">if</span> minc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">A</span><span style="color:#ba2121">&#39;</span> <span style="color:#a2f;font-weight:bold">and</span> maxc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">G</span><span style="color:#ba2121">&#39;</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">2</span> <span style="color:#408080;font-style:italic"># transition</span>
    <span style="color:#008000;font-weight:bold">elif</span> minc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">C</span><span style="color:#ba2121">&#39;</span> <span style="color:#a2f;font-weight:bold">and</span> maxc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">T</span><span style="color:#ba2121">&#39;</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">2</span> <span style="color:#408080;font-style:italic"># transition</span>
    <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">4</span> <span style="color:#408080;font-style:italic"># transversion</span>

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">globalAlignment</span>(x, y, s):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#34;&#34;&#34;</span><span style="color:#ba2121"> Calculate global alignment value of sequences x and y using</span><span style="color:#ba2121">
</span><span style="color:#ba2121"></span><span style="color:#ba2121">        dynamic programming.  Return global alignment value. </span><span style="color:#ba2121">&#34;&#34;&#34;</span>
    D <span style="color:#666">=</span> zeros((<span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>), dtype<span style="color:#666">=</span><span style="color:#008000">int</span>)
    <span style="color:#008000;font-weight:bold">for</span> j <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>):
        D[<span style="color:#666">0</span>, j] <span style="color:#666">=</span> D[<span style="color:#666">0</span>, j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>, y[j<span style="color:#666">-</span><span style="color:#666">1</span>])
    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>):
        D[i, <span style="color:#666">0</span>] <span style="color:#666">=</span> D[i<span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#666">0</span>] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>)
    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>):
        <span style="color:#008000;font-weight:bold">for</span> j <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>):
            D[i, j] <span style="color:#666">=</span> <span style="color:#008000">min</span>(D[i<span style="color:#666">-</span><span style="color:#666">1</span>, j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], y[j<span style="color:#666">-</span><span style="color:#666">1</span>]), <span style="color:#408080;font-style:italic"># diagonal</span>
                          D[i<span style="color:#666">-</span><span style="color:#666">1</span>, j  ] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>),    <span style="color:#408080;font-style:italic"># vertical</span>
                          D[i  , j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>,    y[j<span style="color:#666">-</span><span style="color:#666">1</span>])) <span style="color:#408080;font-style:italic"># horizontal</span>
    <span style="color:#008000;font-weight:bold">return</span> D, D[<span style="color:#008000">len</span>(x), <span style="color:#008000">len</span>(y)]
    
D, globalAlignmentValue <span style="color:#666">=</span> globalAlignment(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">TACGTCAGC</span><span style="color:#ba2121">&#39;</span>, <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">TATGTCATGC</span><span style="color:#ba2121">&#39;</span>, exampleCost)
<span style="color:#008000;font-weight:bold">print</span>(globalAlignmentValue)
<span style="color:#008000;font-weight:bold">print</span>(D)
</code></pre></div><h2 id="local-alignment">Local alignment</h2>
<p>Global alignment discussed above works only in cases when we truly expect sequences to match across their entire lengths. In majority of biological application this is rarely the case. For instance, suppose you want to compare two bacterial genomes to figure out if they have matching sequences. Local alignment algorithm helps with this challenge. Surprisingly, it is almost identical to the approaches we used before. So here is our problem:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Sequence 1: ##################################################
                              |||||||||||||||||
Sequence 2:         #################################################
</code></pre></div><p>there are two sequences (shown with # characters) and they share a region of high similarity (indicated by vertical lines). How do we find this region? We cannot use global alignment logic here because across the majority of their lengths these sequences are dissimilar.</p>
<p>To approach this problem we will change our penalty strategy. Instead of giving a high value for each mismatch we will instead give negative penalties. Only matches get positive rewards. Here is an example of such <em>scoring matrix</em> (as opposed to the <em>penalty matrix</em> we've used before):</p>
<div>
        $$
        \begin{array}{ c | c  c  c  c  c }
                                     & A & C & G & T & -\\
                                  \hline
                                   A & 2 & \color{blue}{-4} & \color{red}{-4} & \color{blue}{-4} & \color{orange}{-6}\\  
                                   C & \color{blue}{-4} & 2 & \color{blue}{-4} & \color{red}{-4}  & \color{orange}{-6}\\
                                   G & \color{red}{-4} & \color{blue}{-4} & 2 & \color{blue}{-4}  & \color{orange}{-6}\\
                                   T & \color{blue}{-4} & \color{red}{-4} & \color{blue}{-4}  & 2 & \color{orange}{-6}\\
                                   - & \color{orange}{-6} & \color{orange}{-6} & \color{orange}{-6} & \color{orange}{-6} & \\
                                \hline
<pre><code>    \end{array}
    $$
</code></pre>
</div>
<p>Our scoring logic will also change:</p>
<div>
<p>$$D(\alpha\texttt{x},\beta\texttt{y}) = max\begin{cases}
D(\alpha,\beta) + s\texttt{(x,y)} &amp; \<br>
D(\alpha\texttt{x},\beta) + s\texttt{(x,-)} &amp; \<br>
D(\alpha,\beta\texttt{y}) + s\texttt{(-,y)} &amp; \<br>
0
\end{cases}$$</p>
</div>
<p>We are now looking for <strong>maximum</strong> and use <em>0</em> to prevent having negative values in the matrix. This also implies that the first row and column will now be filled with zeros. Let apply this to two sequences:</p>
<p>Now, let's align two sequences:</p>
<p>$\texttt{T A T A T G C G G C G T T T}$</p>
<p>and</p>
<p>$\texttt{G G T A T G C T G G C G C T A}$</p>
<p>Dynamic programming matrix with initialized first row and column will look like this:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                         & \epsilon & T & A & T & A & T & G & C & G & G & C & G & T & T & T\\
                                         \hline
                               \epsilon & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                \hline
                                          G & 0\\
                                \hline
                                          G & 0\\
                                \hline
                                      T & 0\\
                                \hline
                                      A & 0\\ 
                                \hline
                                      T & 0\\
                                \hline
                                      G & 0\\
                                \hline
                                      C & 0\\
                                \hline
                                      T & 0\\
                                \hline
                                      G & 0\\
                                \hline
                                      G & 0\\
                                \hline
                                      C & 0\\
                                \hline
                                      G & 0\\
                                \hline
                                      C & 0\\
                                \hline
                                      T & 0\\
                                \hline
                                      A & 0\\
<p>\end{array}</p>
<p>\</p>
<p>\textbf{Remember}: sequence\ \texttt{X}\ is\ vertical\ while\ \texttt{Y}\ is\ horizontal.</p>
<pre><code>    $$
</code></pre>
</div>
<p>Filling it completely will yield the following matrix. Note that clues to where the local alignment may be are given off by positive numbers in the sea of 0s:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                         & \epsilon & T & A & T & A & T & G & C & G & G & C & G & T & T & T\\
                                         \hline
                               \epsilon & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                \hline
                                          G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & 2 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                          G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & 4 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & 2 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 2 & 2\\
                                \hline
                                      A & 0 & 0 & 4 & 0 & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 
                                \hline
                                      T & 0 & 2 & 0 & 6 & 0 & 6 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 2 & 2\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 2 & 0 & 8 & 2 & 2 & 2 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 10 & 4 & 0 & 4 & 0 & 0 & 0 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & 2 & 0 & 2 & 0 & 4 & 6 & 0 & 0 & 0 & 2 & 2 & 2\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & 6 & 8 & 2 & 2 & 0 & 0 & 0\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & 8 & 4 & 4 & 0 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & 2 & 10 & 4 & 0 & 0 & 0\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 6 & 2 & 4 & \color{red}{12} & 6 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & 2 & 4 & 6 & 8 & 2 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & 2 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 8 & 10 & 4\\
                                \hline
                                      A & 0 & 0 & 4 & 0 & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 4 & 6\\
<p>\end{array}
$$</p>
</div>
<p>To identify to boundary of the local alignment we need to identify the cell with the <strong>highest</strong> value. This cell has value of $\color{red}{12}$ and is highlighted above. Using traceback procedure we will find:</p>
<div>
        $$
        \begin{array}{ c | c | c | c | c | c | c | c | c | c | c | c | c | c }
                                         & \epsilon & T & A & T & A & T & G & C & G & G & C & G & T & T & T\\
                                         \hline
                               \epsilon & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
                                \hline
                                          G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & 2 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                          G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & 4 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & \color{red}2 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 2 & 2\\
                                \hline
                                      A & 0 & 0 & 4 & 0 & \color{red}4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\ 
                                \hline
                                      T & 0 & 2 & 0 & 6 & 0 & \color{red}6 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 2 & 2\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 2 & 0 & \color{red}8 & 2 & 2 & 2 & 0 & 2 & 0 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 2 & \color{red}{10} & 4 & 0 & 4 & 0 & 0 & 0 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & 2 & 0 & 2 & 0 & \color{red}4 & 6 & 0 & 0 & 0 & 2 & 2 & 2\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & \color{red}6 & 8 & 2 & 2 & 0 & 0 & 0\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 2 & \color{red}8 & 4 & 4 & 0 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & 2 & \color{red}{10} & 4 & 0 & 0 & 0\\
                                \hline
                                      G & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 0 & 6 & 2 & 4 & \color{red}{12} & 6 & 0 & 0\\
                                \hline
                                      C & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 4 & 0 & 2 & 4 & 6 & 8 & 2 & 0\\
                                \hline
                                      T & 0 & 2 & 0 & 2 & 0 & 2 & 0 & 0 & 0 & 0 & 0 & 0 & 8 & 10 & 4\\
                                \hline
                                      A & 0 & 0 & 4 & 0 & 4 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 4 & 6\\
<p>\end{array}
$$</p>
</div>
<p>This corresponds to the best local alignment between the two sequences:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"> T A T A T G C - G G C G T T T
     | | | | | * | | | |
 G G T A T G C T G G C G C T A
</code></pre></div><p>Here is a Python representation of this approach:</p>
<div class="highlight"><pre style=";-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#008000;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">numpy</span>

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">exampleCost</span>(xc, yc):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;&#39;&#39;</span><span style="color:#ba2121"> Cost function: 2 to match, -6 to gap, -4 to mismatch </span><span style="color:#ba2121">&#39;&#39;&#39;</span>
    <span style="color:#008000;font-weight:bold">if</span> xc <span style="color:#666">==</span> yc: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">2</span> <span style="color:#408080;font-style:italic"># match</span>
    <span style="color:#008000;font-weight:bold">if</span> xc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span> <span style="color:#a2f;font-weight:bold">or</span> yc <span style="color:#666">==</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>: <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">6</span> <span style="color:#408080;font-style:italic"># gap</span>
    <span style="color:#008000;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">4</span>

<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">smithWaterman</span>(x, y, s):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;&#39;&#39;</span><span style="color:#ba2121"> Calculate local alignment values of sequences x and y using</span><span style="color:#ba2121">
</span><span style="color:#ba2121"></span><span style="color:#ba2121">        dynamic programming.  Return maximal local alignment value. </span><span style="color:#ba2121">&#39;&#39;&#39;</span>
    V <span style="color:#666">=</span> numpy<span style="color:#666">.</span>zeros((<span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>), dtype<span style="color:#666">=</span><span style="color:#008000">int</span>)
    <span style="color:#008000;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(x)<span style="color:#666">+</span><span style="color:#666">1</span>):
        <span style="color:#008000;font-weight:bold">for</span> j <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#008000">range</span>(<span style="color:#666">1</span>, <span style="color:#008000">len</span>(y)<span style="color:#666">+</span><span style="color:#666">1</span>):
            V[i, j] <span style="color:#666">=</span> <span style="color:#008000">max</span>(V[i<span style="color:#666">-</span><span style="color:#666">1</span>, j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], y[j<span style="color:#666">-</span><span style="color:#666">1</span>]), <span style="color:#408080;font-style:italic"># diagonal</span>
                          V[i<span style="color:#666">-</span><span style="color:#666">1</span>, j  ] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>),    <span style="color:#408080;font-style:italic"># vertical</span>
                          V[i  , j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>,    y[j<span style="color:#666">-</span><span style="color:#666">1</span>]), <span style="color:#408080;font-style:italic"># horizontal</span>
                          <span style="color:#666">0</span>)                               <span style="color:#408080;font-style:italic"># empty</span>
    argmax <span style="color:#666">=</span> numpy<span style="color:#666">.</span>where(V <span style="color:#666">==</span> V<span style="color:#666">.</span>max())
    <span style="color:#008000;font-weight:bold">return</span> V, <span style="color:#008000">int</span>(V[argmax])
    
<span style="color:#008000;font-weight:bold">def</span> <span style="color:#00f">traceback</span>(V, x, y, s):
    <span style="color:#ba2121"></span><span style="color:#ba2121">&#34;&#34;&#34;</span><span style="color:#ba2121"> Trace back from given cell in local-alignment matrix V </span><span style="color:#ba2121">&#34;&#34;&#34;</span>
    <span style="color:#408080;font-style:italic"># get i, j for maximal cell</span>
    i, j <span style="color:#666">=</span> numpy<span style="color:#666">.</span>unravel_index(numpy<span style="color:#666">.</span>argmax(V), V<span style="color:#666">.</span>shape)
    xscript, alx, aly, alm <span style="color:#666">=</span> [], [], [], []
    <span style="color:#008000;font-weight:bold">while</span> (i <span style="color:#666">&gt;</span> <span style="color:#666">0</span> <span style="color:#a2f;font-weight:bold">or</span> j <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) <span style="color:#a2f;font-weight:bold">and</span> V[i, j] <span style="color:#666">!=</span> <span style="color:#666">0</span>:
        diag, vert, horz <span style="color:#666">=</span> <span style="color:#666">0</span>, <span style="color:#666">0</span>, <span style="color:#666">0</span>
        <span style="color:#008000;font-weight:bold">if</span> i <span style="color:#666">&gt;</span> <span style="color:#666">0</span> <span style="color:#a2f;font-weight:bold">and</span> j <span style="color:#666">&gt;</span> <span style="color:#666">0</span>:
            diag <span style="color:#666">=</span> V[i<span style="color:#666">-</span><span style="color:#666">1</span>, j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], y[j<span style="color:#666">-</span><span style="color:#666">1</span>])
        <span style="color:#008000;font-weight:bold">if</span> i <span style="color:#666">&gt;</span> <span style="color:#666">0</span>:
            vert <span style="color:#666">=</span> V[i<span style="color:#666">-</span><span style="color:#666">1</span>, j] <span style="color:#666">+</span> s(x[i<span style="color:#666">-</span><span style="color:#666">1</span>], <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>)
        <span style="color:#008000;font-weight:bold">if</span> j <span style="color:#666">&gt;</span> <span style="color:#666">0</span>:
            horz <span style="color:#666">=</span> V[i, j<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">+</span> s(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>, y[j<span style="color:#666">-</span><span style="color:#666">1</span>])
        <span style="color:#008000;font-weight:bold">if</span> diag <span style="color:#666">&gt;</span><span style="color:#666">=</span> vert <span style="color:#a2f;font-weight:bold">and</span> diag <span style="color:#666">&gt;</span><span style="color:#666">=</span> horz:
            match <span style="color:#666">=</span> x[i<span style="color:#666">-</span><span style="color:#666">1</span>] <span style="color:#666">==</span> y[j<span style="color:#666">-</span><span style="color:#666">1</span>]
            xscript<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">M</span><span style="color:#ba2121">&#39;</span> <span style="color:#008000;font-weight:bold">if</span> match <span style="color:#008000;font-weight:bold">else</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">R</span><span style="color:#ba2121">&#39;</span>)
            alm<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">|</span><span style="color:#ba2121">&#39;</span> <span style="color:#008000;font-weight:bold">if</span> match <span style="color:#008000;font-weight:bold">else</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121"> </span><span style="color:#ba2121">&#39;</span>)
            alx<span style="color:#666">.</span>append(x[i<span style="color:#666">-</span><span style="color:#666">1</span>]); aly<span style="color:#666">.</span>append(y[j<span style="color:#666">-</span><span style="color:#666">1</span>])
            i <span style="color:#666">-</span><span style="color:#666">=</span> <span style="color:#666">1</span>; j <span style="color:#666">-</span><span style="color:#666">=</span> <span style="color:#666">1</span>
        <span style="color:#008000;font-weight:bold">elif</span> vert <span style="color:#666">&gt;</span><span style="color:#666">=</span> horz:
            xscript<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">D</span><span style="color:#ba2121">&#39;</span>)
            alx<span style="color:#666">.</span>append(x[i<span style="color:#666">-</span><span style="color:#666">1</span>]); aly<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>); alm<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121"> </span><span style="color:#ba2121">&#39;</span>)
            i <span style="color:#666">-</span><span style="color:#666">=</span> <span style="color:#666">1</span>
        <span style="color:#008000;font-weight:bold">else</span>:
            xscript<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">I</span><span style="color:#ba2121">&#39;</span>)
            aly<span style="color:#666">.</span>append(y[j<span style="color:#666">-</span><span style="color:#666">1</span>]); alx<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">-</span><span style="color:#ba2121">&#39;</span>); alm<span style="color:#666">.</span>append(<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121"> </span><span style="color:#ba2121">&#39;</span>)
            j <span style="color:#666">-</span><span style="color:#666">=</span> <span style="color:#666">1</span>
    xscript <span style="color:#666">=</span> (<span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">&#39;</span><span style="color:#666">.</span>join(xscript))[::<span style="color:#666">-</span><span style="color:#666">1</span>]
    alignment <span style="color:#666">=</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#ba2121">&#39;</span><span style="color:#666">.</span>join(<span style="color:#008000">map</span>(<span style="color:#008000;font-weight:bold">lambda</span> x: <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">&#39;</span><span style="color:#666">.</span>join(x), [alx[::<span style="color:#666">-</span><span style="color:#666">1</span>], alm[::<span style="color:#666">-</span><span style="color:#666">1</span>], aly[::<span style="color:#666">-</span><span style="color:#666">1</span>]]))
    <span style="color:#008000;font-weight:bold">return</span> xscript, alignment

x, y <span style="color:#666">=</span> <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">GGTATGCTGGCGCTA</span><span style="color:#ba2121">&#39;</span>, <span style="color:#ba2121"></span><span style="color:#ba2121">&#39;</span><span style="color:#ba2121">TATATGCGGCGTTT</span><span style="color:#ba2121">&#39;</span>
V, best <span style="color:#666">=</span> smithWaterman(x, y, exampleCost)
<span style="color:#008000;font-weight:bold">print</span>(V)
<span style="color:#008000;font-weight:bold">print</span>(<span style="color:#ba2121"></span><span style="color:#ba2121">&#34;</span><span style="color:#ba2121">Best score=</span><span style="color:#b68;font-weight:bold">%d</span><span style="color:#ba2121">, in cell </span><span style="color:#b68;font-weight:bold">%s</span><span style="color:#ba2121">&#34;</span> <span style="color:#666">%</span> (best, numpy<span style="color:#666">.</span>unravel_index(numpy<span style="color:#666">.</span>argmax(V), V<span style="color:#666">.</span>shape)))
<span style="color:#008000;font-weight:bold">print</span>(traceback(V, x, y, exampleCost)[<span style="color:#666">1</span>])
</code></pre></div><p>This algorithm was developed by <a href="http://dornsife.usc.edu/assets/sites/516/docs/papers/msw_papers/msw-042.pdf">Temple Smith and Michael Waterman</a> in 1981. This is why it is most often called Smith Waterman local alignment algorithm.</p>
<h1 id="homework">Homework</h1>
<ul>
<li>Modify the last code snippet of this lecture (local alignment code) to output seaborn heatmap visualization of the matrix. Use any color scheme that is not default.</li>
<li>Produce similar heatmap using matrix visualization function of <a href="https://toyplot.readthedocs.io/en/stable/matrix-visualization.html"><code>toyplot</code></a>. To do this you will need to install <code>toyplot</code> into your notebook using <code>pip</code>.</li>
</ul>



      </main>
    </div>
    <footer id="footer" class="mt-auto text-center text-muted">
  <div class="container">
    Nekrutenko Lab 2020 | CC-BY
  </div>
</footer>
    <script src="https://nekrut.github.io/BMMB554/js/feather.min.js"></script>
<script>
  feather.replace()
</script>


    
  

  </body>
</html>